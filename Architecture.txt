Architecture notes.

The SAPI interface is a minimal system call layer to support the needs of Forth.
Its a textbook implementation for the Cortex-M - It uses the SVC instruction.

There is a deeply important assumption here - the SAPI layer does NOT provide 
task-management.  Task/thread management is provided by the client application.

Terminology:
- Supervisor
 Runs at power-on reset and uses the master stack pointer.  
 It initializes all hardware and then loads the program stack pointer from the client image
 and launches the client.   

- Client.
 This is a minimal Cortex-M binary.   It only requires the first two Cortex-M vectors -
 The initial stack pointer and the initial program counter.

The sample code includes a SVC Exception handler that interfaces to the 
system calls which in this case are written in C.

System Call Parameters/Return codes are documented in svchandler.S

In order to startup the client application, you will need to use the supplied
pendsv handler.  It'll construct a stack frame that unrolls from exception mode and
starts the client.

-----------------------------------------------------------------
Power Reduction.

The most basic thing is to issue a WFI.  Levels of complexity:

No Multitasker - have KEY issue a WFI if no input before trying again.
Multitasker without integrated WFI
 Create a task that does wfi, pause forever and add it to the task list.
 see cm3forthtools/idlewfi for an example.
Multitasker with integrated WFI
 Idle task must STOP themselves.  The multitasker will issue the WFI
 when there are no runnable tasks.   This is the best performing solution,
 but the most complex to implement.

-----------------------------------------------------------------
Blocking IO.

If the scheduler supports it, blocking IO is very efficient.  The 
system call takes a task control block pointer as an argument.  If the 
call needs to block, the system call then puts the task to sleep
by clearing bit 0 of the task's status byte, and saves the pointer 
to use when a wake event happens.  When the wake event happens,
the supervisor sets bit zero of the status word to 1.

While the task could put itself to sleep, that creates a hazard - 
the task could put itself to sleep immediately after a wake-triggering
exception.

This is predicated upon the use of a thread scheduler with integrated
WFI.  A sample is available.

The blocking calls can be used in partially-implemented systems -
Define SAPIWakeSupport? in for the system call words to pass UP to the system calls.
Leave it undefined to pass in 0, disabling wake events.

The supervisor calls can also ignore the supplied TCB, in which case the system
call words will just spin through PAUSE or WFI until something unblocks.

-----------------------------------------------------------------
Implementation Levels.   As the implementation complexity level goes
up, more things are possible.  To reduce power, use the WFI instruction
whenever possible to power down the CPU until something interesting happens.

!!!!!!!!!!!!!!!!!!  Important !!!!!!!!!!!!!!!!!!!!!
System calls can't block.  The SAPI is designed to support the needs
of a client application that provides it's own mechanism for blocking.


Level 0 - Putchar/EMIT,  CharsAvailable/KEY?, Getchar/KEY.
Thin wrappers around device access.  No interrupts. KEY can issue a WFI if there is
no input available, or issue a WFI when Putchar returns full/blocked

These are all it takes to get up and going.  Forth polls via the system calls.  Implementations
that use interrupts as part of serial device management can use WFI for power savings.

Level 1 - Putchar/EMIT,  CharsAvailable/KEY?, Getchar/KEY.
IO Devices that generate interrupts and return a status code to indicate that
the calling task should yield/pause.  

Level 2 - Putchar/EMIT,  CharsAvailable/KEY?, Getchar/KEY, CR, TYPE
IO Devices that generate interrupts and return a status code to indicate that
the calling task should yield/pause.  CR and TYPE make sense on alternate 
output devices.

-----------------------------------------------------------------
Dynamic Linking/Jump Tables.

The supplied code includes a basic mechanism for exporting C (or other language)
memory addresses or parameters to forth.  It defines a simple data structure
that dylink.fth parses to create CONSTANTS at runtime or update the contents of VALUES.

The GetRuntimeData syscall returns this value when called with an argument of zero.


